using namespace::std;
struct Column;

struct Node {
    Node *L, *R, *U, *D;
    Column *C;     // Column this node belongs to
    int rowID;     // For backtracking Sudoku solution

    Node() : L(this), R(this), U(this), D(this), C(nullptr), rowID(-1) {}
};

struct Column : Node {
    int size;       // Number of nodes in this column
    std::string name;

    Column(const std::string &n="") : Node(), size(0), name(n) { C = this; }
};

class DLX {
public:
    Column head;              // Sentinel header
    vector<Column*> cols;
    vector<Node*> nodes;

    vector<int> solution;

    DLX(int numCols) {
        cols.reserve(numCols);
        for (int i = 0; i < numCols; i++) {
            Column* c = new Column(std::to_string(i));
            cols.push_back(c);
            insertColumn(c);
        }
    }

    ~DLX() {
        for (auto c : cols) delete c;
        for (auto n : nodes) delete n;
    }

private:
    void insertColumn(Column* c) {
        c->R = head.R;
        c->L = &head;
        head.R->L = c;
        head.R = c;
    }
public:
    Node* addNode(int colIndex, int rowID) {
        Column* c = cols[colIndex];
        Node* n = new Node();
        nodes.push_back(n);

        // Vertical insert
        n->D = c;
        n->U = c->U;
        c->U->D = n;
        c->U = n;

        n->C = c;
        c->size++;
        n->rowID = rowID;
        return n;
    }

    void linkRow(const std::vector<Node*>& row) {
        for (int i = 0; i < (int)row.size(); i++) {
            Node* a = row[i];
            Node* b = row[(i + 1) % row.size()];

            a->R = b;
            b->L = a;
        }
    }

    void cover(Column* c) {
        c->R->L = c->L;
        c->L->R = c->R;

        for (Node* row = c->D; row != c; row = row->D) {
            for (Node* node = row->R; node != row; node = node->R) {
                node->D->U = node->U;
                node->U->D = node->D;
                node->C->size--;
            }
        }
    }

    void uncover(Column* c) {
        for (Node* row = c->U; row != c; row = row->U) {
            for (Node* node = row->L; node != row; node = node->L) {
                node->C->size++;
                node->D->U = node;
                node->U->D = node;
            }
        }
        c->R->L = c;
        c->L->R = c;
    }
    bool search() {
        if (head.R == &head) return true; // success

        // Choose column with fewest nodes
        Column* c = nullptr;
        int minSize = 1e9;
        for (Column* j = (Column*)head.R; j != &head; j = (Column*)j->R) {
            if (j->size < minSize) {
                minSize = j->size;
                c = j;
            }
        }

        cover(c);

        for (Node* r = c->D; r != c; r = r->D) {
            solution.push_back(r->rowID);

            for (Node* j = r->R; j != r; j = j->R)
                cover(j->C);

            if (search()) return true;

            for (Node* j = r->L; j != r; j = j->L)
                uncover(j->C);

            solution.pop_back();
        }

        uncover(c);
        return false;
    }
};
